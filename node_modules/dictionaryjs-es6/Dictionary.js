"use strict";

class Dictionary {

	constructor(resume) {

		this.handler = {
			get: this._getHandler,
			set: this._setHandler,
			has: this._hasHandler,
			deleteProperty: this._deleteHandler
		};

		this.target = {
			data: {},	//holds the user's key/value pairs
			invalidateKeys: false,
			keys: null,	//array of keys
			resume_next: null,
			resume: resume
		};

		this.target.initHandleCallback = () => {
			if (this.target.resume)
				this.target.resume_next = this.target.resume();
			else
				this.target.resume_next = null;
		};

		this.target.handleCallback = (cb, err, result) => {
			if (err)
				this.target.last_error = err;
			else
				this.target.last_error = null;

			if (cb)
				cb(err, result, this.target.resume_next);
			else if (this.target.resume_next)
				this.target.resume_next(err, result);
		};

		this.target.methods = {
			setResume: (resume) => {
				this.target.resume = resume;
			},
			invalidate: () => {
				console.log("invalidate called");
				this.target.invalidateKeys = true;
			},
			set: (key,value) => {
				this.target.data[key] = value;
				this.target.invalidateKeys = true;
			},
			get: (key) => {
				return this.target.data[key];
			},
			getDefault: (key,defaultValue) => {
				if (this.target.methods.has(key)) {
					return this.target.data[key];
				} else {
					return defaultValue;
				}
			},
			remove: (key) => {
				delete this.target.data[key];
				this.target.invalidateKeys = true;
			},
			empty: () => {
				this.target.methods.forEach((id,obj) => {
					this.target.methods.remove(id);
				});
			},
			asyncEmpty: (cbEnd) => {
				this.target.methods.asyncForEach((id,obj,next) => {
					this.target.methods.remove(id);
					next();
				},cbEnd);
			},
			has: (key) => {
				return this.target.data.hasOwnProperty(key);
			},
			size: () => {
				return this.target.methods.getKeys().length;
			},
			forEach: (cbEach) => {
				for (let key in this.target.data) {
					if (this.target.data.hasOwnProperty(key)) {
						if (cbEach(key,this.target.data[key]) == false) break;
					}
				}
			},
			asyncForEach: (cbIterator,cbFinal,enableCallback) => {
				if (enableCallback==null) enableCallback = true;
				var self = this.target;
				if (enableCallback) self.initHandleCallback();

				var keys = self.methods.getKeys();
				var counter = 0;
				var len = keys.length;
				var data = self.data;

				var next = function () {
					if (counter < len && data != null) {
						process.nextTick(step);
					} else {
						if (enableCallback)  self.handleCallback(cbFinal);
						return;
					}
				};
				var step = function () {
					if (counter < len && data != null) {
						var key = keys[counter++];
						if (cbIterator(key, data[key], next) == false) {
							if (enableCallback) self.handleCallback(cbFinal);
							return;
						}

					} else {
						if (enableCallback) self.handleCallback(cbFinal);
						return;
					}
				};
				step();
				
			},
			getKeys: () => {
				if (this.target.invalidateKeys || this.target.keys==null) {
					this.target.keys = Object.keys(this.target.data);
					this.target.invalidateKeys = false;
					return this.target.keys;
				} else {
					return this.target.keys;
				}
			}
		};

		this.target.properties = {
			length: this.target.methods.size,
			keys: this.target.methods.getKeys
		};



		return new Proxy(this.target,this.handler);
	}

	//-------------------------------------------------------
	// Proxy Handlers
	//-------------------------------------------------------

	_getHandler(target,key) {

		if (key == Symbol.iterator)
			return function*() {
				for (let key of target.methods.getKeys()) {
					yield target.data[key];
				}
			};


		if (target.methods.hasOwnProperty(key))
			return target.methods[key];

		if (key=="hasOwnProperty")
			return target.methods.has;

		if (target.properties.hasOwnProperty(key))
			return target.properties[key]();

		if (target.data.hasOwnProperty(key))
			return target.data[key];

		return null;
	}

	_setHandler(target,key,value) {

		if (target.methods.hasOwnProperty(key) ||
			key=="hasOwnProperty" ||
			target.properties.hasOwnProperty(key)
		)
			throw new Error("Property '"+key+"' is a reserved name and cannot be used.");

		target.data[key] = value;
		target.invalidateKeys = true;
		return true;
	}

	_hasHandler(target,key) {
		return target.methods.has(key);
	}

	_deleteHandler(target,key) {
		target.methods.remove(key);
		return true;
	}

	//-------------------------------------------------------
	// Methods for IntelliSense (see above for implementation)
	//-------------------------------------------------------

	/**
	 * Store value at the key.  The key has been tested with strings,
	 *   but may support other types.
	 * Value may be any data type.
	 * @param {string} key - key of the key/value pair
	 * @param value - value of the key/value pair
     */
	set(key,value) {

	}

	/**
	 * Returns the value
	 * @param key
	 * @returns value of the key/value pair
     */
	get(key) {

	}

	/**
	 * Enables support to work with the suspend module.
	 * Pass in the suspend.resume reference to this method, or to the constructor directly.
	 * @param resume - suspend.resume reference
     */
	setResume(resume) {

	}

	/**
	 * Returns the default value if key is not found or is null.
	 * @param {string} key - key to lookup
	 * @param defaultValue - the default value
	 * @returns value of key or default value
     */
	getDefault(key,defaultValue) {

	}

	/**
	 * Removes key from dictionary collection.
	 * @param {string} key - key to remove
     */
	remove(key) {

	}

	/**
	 * Removes all keys from collection.
	 * This is blocking.
	 */
	empty() {

	}

	/**
	 * Non-blocking method to remove all keys from collection.
	 * @param [cb=null] - cbComplete() called after collection is emptied
	 * 		Optional: leave null to use yield (suspend module)
     */
	asyncEmpty(cbComplete) {

	}

	/**
	 * Check if key exists within the collection
	 * @param {string} key - Key to check
	 * @returns boolean True if key is found
     */
	has(key) {

	}

	/**
	 * See has.
	 * @param {string} key - Key to check
	 * @returns boolean True if key is found
     */
	hasOwnProperty(key) {

	}

	/**
	 * Returns how many keys are found within the collection.
	 * @returns int
	 */
	size() {

	}

	/**
	 * Blocking loop helper method.
	 * @param cbIteration - cbIteration(key,value)
     */
	forEach(cbIteration) {

	}

	/**
	 * Non-blocking loop helper method.
	 * Must call cbNext within cbIteration to move to the next item in the collection.
	 * Example:
	 * <pre>
	 *     collection.asyncForEach(
	 *     function(key,value,cbNext) {
	 *     		console.log(key,value);
	 * 	    	cbNext();
	 *     },
	 *     function() {
	 *     		console.log("loop complete");
	 *     });
	 * </pre>
	 * @param cbIteration - cbIteration(key,value,cbNext)
	 * @param [cbComplete=null] - cbComplete() called after loop complete
	 * 		Optional: leave null to use yield (suspend module)
     */
	asyncForEach(cbIteration,cbComplete) {

	}

}


module.exports = Dictionary;